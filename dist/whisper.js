"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.whisperShell = whisperShell;
exports.executeCppCommand = executeCppCommand;
const shelljs_1 = __importDefault(require("shelljs"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const constants_1 = require("./constants");
const projectDir = process.cwd();
const defaultShellOptions = {
    silent: false,
    async: true,
};
function handleError(error, logger = console) {
    logger.error('[Nodejs-whisper] Error:', error.message);
    shelljs_1.default.cd(projectDir);
    throw error;
}
// Get the correct executable path based on platform and build system
function getWhisperExecutablePath() {
    const execName = process.platform === 'win32' ? 'whisper-cli.exe' : 'whisper-cli';
    // Check common CMake build locations
    const possiblePaths = [
        path_1.default.join(constants_1.WHISPER_CPP_PATH, 'build', 'bin', execName), // Unix CMake
        path_1.default.join(constants_1.WHISPER_CPP_PATH, 'build', 'bin', 'Release', execName), // Windows CMake Release
        path_1.default.join(constants_1.WHISPER_CPP_PATH, 'build', 'bin', 'Debug', execName), // Windows CMake Debug
        path_1.default.join(constants_1.WHISPER_CPP_PATH, 'build', execName), // Alternative location
        path_1.default.join(constants_1.WHISPER_CPP_PATH, execName), // Root directory
    ];
    for (const execPath of possiblePaths) {
        if (fs_1.default.existsSync(execPath)) {
            return execPath;
        }
    }
    return ''; // Not found
}
// Check if whisper-cli executable exists
function checkExecutableExists(logger = console) {
    const execPath = getWhisperExecutablePath();
    const exists = execPath !== '';
    if (exists) {
        logger.debug(`[Nodejs-whisper] Found executable at: ${execPath}`);
    }
    else {
        logger.debug('[Nodejs-whisper] Executable not found in any expected location');
    }
    return exists;
}
// Check if build directory exists and has been configured
function isBuildConfigured() {
    const buildDir = path_1.default.join(constants_1.WHISPER_CPP_PATH, 'build');
    const cmakeCache = path_1.default.join(buildDir, 'CMakeCache.txt');
    return fs_1.default.existsSync(buildDir) && fs_1.default.existsSync(cmakeCache);
}
function whisperShell(command_1) {
    return __awaiter(this, arguments, void 0, function* (command, options = defaultShellOptions, logger = console) {
        return new Promise((resolve, reject) => {
            const shellOptions = Object.assign(Object.assign({}, options), { windowsHide: true });
            shelljs_1.default.exec(command, shellOptions, (code, stdout, stderr) => {
                logger.debug('Exit code:', code);
                logger.debug('Stdout:', stdout);
                logger.debug('Stderr:', stderr);
                if (code === 0) {
                    if (stdout.includes('error:')) {
                        reject(new Error('Error in whisper.cpp:\n' + stdout));
                        return;
                    }
                    logger.debug('[Nodejs-whisper] Transcribing Done!');
                    resolve(stdout);
                }
                else {
                    reject(new Error(stderr || `Command failed with exit code ${code}`));
                }
            });
        }).catch((error) => {
            handleError(error, logger);
            return Promise.reject(error);
        });
    });
}
function executeCppCommand(command_1) {
    return __awaiter(this, arguments, void 0, function* (command, logger = console, withCuda = false, silent = false) {
        try {
            shelljs_1.default.cd(constants_1.WHISPER_CPP_PATH);
            // Check if executable already exists
            if (!checkExecutableExists(logger)) {
                logger.debug('[Nodejs-whisper] whisper-cli executable not found. Building...');
                // Configure build if not already configured
                if (!isBuildConfigured()) {
                    logger.debug('[Nodejs-whisper] Configuring CMake build...');
                    let configureCommand = 'cmake -B build';
                    if (withCuda) {
                        configureCommand += ' -DGGML_CUDA=1';
                    }
                    const configResult = shelljs_1.default.exec(configureCommand);
                    if (configResult.code !== 0) {
                        throw new Error(`[Nodejs-whisper] CMake configuration failed: ${configResult.stderr}`);
                    }
                    logger.debug('[Nodejs-whisper] CMake configuration completed.');
                }
                else {
                    logger.debug('[Nodejs-whisper] Build already configured.');
                }
                // Build the project
                logger.debug('[Nodejs-whisper] Building whisper.cpp...');
                const buildCommand = 'cmake --build build --config Release';
                const buildResult = shelljs_1.default.exec(buildCommand);
                if (buildResult.code !== 0) {
                    throw new Error(`[Nodejs-whisper] Build failed: ${buildResult.stderr}`);
                }
                // Verify executable was created
                if (!checkExecutableExists(logger)) {
                    throw new Error('[Nodejs-whisper] Build completed but executable not found. Please check the build output for errors.');
                }
                logger.log('[Nodejs-whisper] Build completed successfully.');
            }
            else {
                logger.debug('[Nodejs-whisper] whisper-cli executable found. Skipping build.');
            }
            const shellOptions = {
                silent: silent,
                async: true,
            };
            return yield whisperShell(command, shellOptions, logger);
        }
        catch (error) {
            handleError(error, logger);
            throw error;
        }
    });
}
//# sourceMappingURL=whisper.js.map